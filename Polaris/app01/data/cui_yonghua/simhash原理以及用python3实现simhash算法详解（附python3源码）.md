
--- 
title:  simhash原理以及用python3实现simhash算法详解（附python3源码） 
tags: []
categories: [] 

---
### 1. 为什么需要Simhash?

传统相似度算法：文本相似度的计算，一般使用向量空间模型(VSM)，先对文本分词，提取特征，根据特征建立文本向量，把文本之间相似度的计算转化为特征向量距离的计算，如欧式距离、余弦夹角等。

缺点：大数据情况下复杂度会很高。

`Simhash应用场景`：<mark>计算大规模文本相似度，实现海量文本信息去重。</mark>

`Simhash算法原理`：<mark>通过hash值比较相似度，通过两个字符串计算出的hash值，进行异或操作，然后得到相差的个数，数字越大则差异越大。</mark>

`Simhash的缺点`：**完全无关的文本正好对应成了相同的simhash，精确度并不是很高，而且simhash更适用于较长的文本，但是在大规模语料进行去重时，simhash的计算速度优势还是很不错的。**

### 2. 文章关键词特征提取算法TD-IDF

`词频（TF）`：一个词语在整篇文章中出现的次数与词语总个数之比；

`逆向词频（IDF)`：一个词语，在所有文章中出现的频率都非常高，这个词语不具有代表性，就可以降低其作用，也就是赋予其较小的权值。 <img src="https://img-blog.csdnimg.cn/8904aedcdea743f89ef0d390e135e585.png" alt="请添加图片描述">

分子代表文章总数，分母表示该词语在这些文章出现的篇数。一般会采取分母加一的方法，防止分母为0的情况出现，在这个比值之后取对数，就是IDF了。

最终用 `tf*idf` 得到一个词语的权重，进而计算一篇文章的关键词。然后根据每篇文章对比其关键词的方法来对文章进行去重。<mark>simhash算法对效率和性能进行平衡，既可以很少的对比（关键词不能取太多），又能有好的代表性（关键词不能过少）。</mark>

### 3. simhash的实现

**simhash具体实现步骤如下：**

 1. 将文档分词，取一个文章的TF-IDF权重最高的前20个词（feature）和权重（weight）。即一篇文档得到一个长度为20的（feature：weight）的集合。
 1. 对其中的词（feature），进行普通的哈希之后得到一个64为的二进制，得到长度为20的（hash : weight）的集合。
 1. 根据（2）中得到一串二进制数（hash）中相应位置是1是0，对相应位置取正值weight和负值weight。例如一个词进过（2）得到（010111：5）进过步骤（3）之后可以得到列表[-5,5,-5,5,5,5]。由此可以得到20个长度为64的列表[weight，-weight…weight]代表一个文档。
 1. 对（3）中20个列表进行列向累加得到一个列表。如[-5,5,-5,5,5,5]、[-3,-3,-3,3,-3,3]、[1,-1,-1,1,1,1]进行列向累加得到[-7，1，-9，9，3，9]，这样，我们对一个文档得到，一个长度为64的列表。
 1. 对（4）中得到的列表中每个值进行判断，当为负值的时候去0，正值取1。例如，[-7，1，-9，9，3，9]得到010111，这样就得到一个文档的simhash值了。
 1. 计算相似性。两个simhash取异或，看其中1的个数是否超过3。超过3则判定为不相似，小于等于3则判定为相似。

**Simhash整体流程图如下：** <img src="https://img-blog.csdnimg.cn/d9246227d7354a8a922c8cdd01b451b0.png" alt="请添加图片描述">

### 4. 用python3算法实现simhash

```
# -*- encoding: utf-8 -*-


class Simhash:
    def 
```
