
--- 
title:  分布式锁特点、以及用python3实现redis分布式锁 
tags: []
categories: [] 

---
#### 1、概述

官方文档：

对于分布式场景，我们可以使用分布式锁，它是控制分布式系统之间互斥访问共享资源的一种方式。 比如说在一个分布式系统中，多台机器上部署了多个服务，当客户端一个用户发起一个数据插入请求时，如果没有分布式锁机制保证，那么那多台机器上的多个服务可能进行并发插入操作，导致数据重复插入，对于某些不允许有多余数据的业务来说，这就会造成问题。而分布式锁机制就是为了解决类似这类问题，保证多个服务之间互斥的访问共享资源，如果一个服务抢占了分布式锁，其他服务没获取到锁，就不进行后续操作。

#### 2、分布式锁特点

分布式锁一般有如下的特点：

 - 互斥性： 同一时刻只能有一个线程持有锁
 - 可重入性： 同一节点上的同一个线程如果获取了锁之后能够再次获取锁
 - 锁超时：和J.U.C中的锁一样支持锁超时，防止死锁
 - 高性能和高可用： 加锁和解锁需要高效，同时也需要保证高可用，防止分布式锁失效
 - 具备阻塞和非阻塞性：能够及时从阻塞状态中被唤醒

#### 3、分布式锁的实现方式

我们一般实现分布式锁有以下几种方式：

 - 基于数据库
 - 基于Redis
 - 基于zookeeper

#### 4、用python3实现redis分布式锁

实现原理：`WATCH, MULTI, EXEC, DISCARD事务机制实现分布式锁`，事务可以一次执行多个命令， 并且带有以下两个重要的保证：

 - 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
 - 事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。

`EXEC 命令负责触发并执行事务中的所有命令`：如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。 另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。

python3脚本如下：

```
# -*- encoding: utf-8 -*-
import time
import uuid
import redis

from multiprocessing import Process

redis_client = redis.Redis(host='127.0.0.1', port=6379, db=3)


def acquire_lock(lock_name, args, acquire_timeout=30, time_out=120):
    """加锁

    :param lock_name: 加锁名称
    :param args:
    :param acquire_timeout:
    
```
