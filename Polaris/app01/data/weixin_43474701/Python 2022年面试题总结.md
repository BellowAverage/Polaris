
--- 
title:  Python 2022年面试题总结 
tags: []
categories: [] 

---


#### 2022年Python面试题
- <ul><li>- 


>  
 ✅作者简介：大家好我是编程ID 📃个人主页：编程ID的csdn博客 系列专栏：Python 💬推荐一款Python编程题刷题神器👉 


### 一. Python基础

<img src="https://img-blog.csdnimg.cn/3b3662fe43964ab79d5a7d1dac77633d.png" alt="在这里插入图片描述">

**1）字典推导式**

```
d = {<!-- -->key:value for (key,value) in iterable}

```

**2）反转字符串 “aStr”**

```
print("aStr"[::-1])

```

**3）将字符串 “k:1 |k1:2|k2:3|k3:4”，处理成字典 {k:1,k1:2,…}**

```
str1 = "k:1|k1:2|k2:3|k3:4" 
def str2dict(str1): 
 dict1 = {<!-- -->} 
 for iterms in str1.split('|'): 
  key,value = iterms.split(':') 
  dict1[key] = value 
 return dict1 
#字典推导式 
d = {<!-- -->k:int(v) for t in str1.split("|") for k, v in (t.split(":"), )}

```

**4）下面代码的输出结果将是什么**

```
list = ['a','b','c','d','e'] 
print(list[10:])

```

代码将输出[],不会产生IndexError错误，就像所期望的那样，尝试用超出成员的个数的index来获取某 个列表的成员。例如，尝试获取list[10]和之后的成员，会导致IndexError。然而，尝试获取列表的切 片，开始的index超过了成员个数不会产生IndexError，而是仅仅返回一个空列表。这成为特别让人恶 心的疑难杂症，因为运行的时候没有错误产生，导致Bug很难被追踪到。

**5）给定两个列表，怎么找出他们相同的元素和不同的元素**

```
list1 = [1,2,3]
list2 = [3,4,5]
set1 = set(list1)
set2 = set(list2)
print(set1 &amp; set2)
print(set1 ^ set2)

```

**6）Python元组和列表的区别** 答：列表可变，元组不可变。

如果只能回答上面的答案在大厂面试中一定会挂，下面进行详细解答：

元组(tuple)不可变是指它的内存地址不可变，如果元组内的元素是可变类型的值（例如：dict），那其中的元素是可以改变的。例如：

```
a = (1, {<!-- -->'key': 1})
a[1]['key'] = 2
print('改变之后的a的值', a)

```

输出结果

```
改变之后的a的值 (1, {<!-- -->'key': 2})

```

除此之外，元组占用的内存空间更小：

```
a = [1, 2, 3, 4, 5, 6]
print('列表的空间大小为：', a.__sizeof__())
b = (1, 2, 3, 4, 5, 6)
print('元组的空间大小为：', b.__sizeof__())

```

输出结果

```
列表的空间大小为： 136
元组的空间大小为： 72

```

元组可以作为字典的key，而列表不能：

列表作为字典的key时会报错！

```
a = {<!-- -->['a']:1}

```

输出结果

```
TypeError: unhashable type: 'list'

```

元组作为字典的key时则不会报错

```
a = {<!-- -->('a',):1}

```

另外，元组的元素必须用逗号分隔，哪怕只有一个元素：

(‘a’,) 元组和列表的区别总结如下：

元组内存地址不可变，列表内存地址可变； 元组占用空间比列表更少； 元组是不可变参数，所以可以作为字段的key，而列表（可变参数）不能； 元组的元素必须用逗号分隔，哪怕只有一个元素； **7）如何在一个函数内部修改全局变量** 可以使用global修改：

```
a = 1

def test():
    globals()['a'] = 2
    
print('原来的a值：', a)
test()
print('修改后的a值：', a)

```

输出结果

```
原来的a值： 1
修改后的a值： 2

```

函数也可以改成这样：

```
def test():
    global a
    a=2

```

**8）解释一下Python的GIL** GlL是 python的全局解释器锁,同一进程中假如有多个线程运行,一个线程在运行python程序的时候会霸占 python解释器(加了一把锁即GIL),使该进程內的其他线程无法运行,等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作,则解释器锁解开,使其他线程运行。所以在多线程中,线程的运行仍是有先后顺序的,并不是同时进行。多进程中因为每个进程都能被系统分配资源,相当于每个进程有了ー个 python解释器,所以多进程可以实现多个进程的同时运行,缺点是进程系统资源开销大。

**9）Python列表去重** 通过集合的方式去重：

```
a = [1, 2, 2, 3, 3, 6]
a = set(a)  # 先转为集合进行去重
a = list(a)  # 然后再转换为列表
print('去重后的列表', a)

```

手写去重代码：

```
a = [1, 2, 2, 4, 4, 6, 7]
b = []
for i in a:
    if i not in b:
        b.append(i)

print('去重后的列表', b)

```

**10）列出 python中可变数据类型和不可变数据类型,并简述原理** 不可变数据类型：数值型(int)、字符串型(str)和元组(tuple)不允许变量的值发生变化,如果改变了变量的值,相当于是新建了一个对象,而对于相同的值的对象,在内存中则只有一个对象(一个地址)：

```
a = 3
b = 3
print('a的内存地址为', id(a))
print('b的内存地址为', id(b))

```

输出结果

```
a的内存地址为 1658574891376
b的内存地址为 1658574891376

```

可变数据类型：列表(list)和字典(dict)，允许变量的值发生变化,即如果对变量进行 append、+=等这种操作后,只是改变了变量的值,而不会新建一个对象,变量引用的对象的地址也不会变化,不过对于相同的值的不同对象,在内存中则会存在不同的对象,即每个对象都有自己的地址,相当于内存中对于同值的对象保存了多份,这里不存在引用计数,是实实在在的对象:

```
a = [1,2]
b = [1,2]
print('a的内存地址为', id(a))
print('b的内存地址为', id(b))

```

输出结果

```
a的内存地址为 2122512488768
b的内存地址为 2122512662720
6）python2和 python3区别
Python3使用 print必须要以小括号包裹打印内容,而在Python2既可以使用带小括号的方式,也可以使用一个空格来分隔打印内容:
print("hello world") #pyton3和python2都可
print "hello world" #python2
python2 range(1,10)返回列表, python3中返回迭代器,节约内存；
python2中使用asci编码, python中使用utf-8编码；
python2中 unicode表示字符串序列,str表示字节序列python3中st表示字符串序列,byte表示字节序列 ；
python2中为正常显示中文,引入 coding声明, python3中不需要；
python2中是 raw input0函数, python3中是 Input0函数；

```

**11）python中内置的数据结构有几种** 整型 int、 长整型 long、浮点型 float、 复数 complex 字符串 str、 列表 list、 元祖 tuple 字典 dict 、 集合 set Python3 中没有 long，只有无限精度的 int **12）下面代码的输出结果将是什么**

```
a = [1,2]
print(a[3:])

```

代码将输出[],不会产生IndexError错误，就像所期望的那样，尝试用超出成员的个数的index来获取某个列表的成员。例如，尝试获取list[10]和之后的成员，会导致IndexError。然而，尝试获取列表的切片，开始的index超过了成员个数不会产生IndexError，而是仅仅返回一个空列表。这成为特别让人恶心的疑难杂症，因为运行的时候没有错误产生，导致Bug很难被追踪到。

***13）Python代码中_args, <em>_kwargs 含义及用法？**</em> args： arguments 的缩写，表示位置参数

kwargs： keyword arguments 的缩写，表示关键字参数

**14）请列出 5 个 python 标准库？** os：提供了不少与操作系统相关联的函数 sys: 通常用于命令行参数 re: 正则匹配 math: 数学运算 datetime:处理日期时间 **15）Python的可变数据类型和不可变数据类型分别有？** 可变数据类型：列表、字典、集合

不可变数据类型：数字、字符串、元组

**16）Python 中魔法方法和其用途？** **init**：对象初始化方法

**new**：创建对象时候执行的方法，单列模式会用到

**str**:当使用print输出对象的时候，只要自己定义了__str__(self)方法，那么就会打印从在这个方法中return的数据

**del**：删除对象执行的方法

**17）Python 中os和sys模块的作用分别是？** os模块：负责程序与操作系统的交互，提供了访问操作系统底层的接口。sys模块：负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。

**18）简述Python引用计数机制？** python垃圾回收主要以引用计数为主，标记-清除和分代清除为辅的机制，其中标记-清除和分代回收主要是为了处理循环引用的难题。

**19）Python赋值、浅拷贝和深拷贝的区别？** Python 有 3 种赋值方式：直接赋值、浅拷贝、深拷贝；

直接赋值：就是对象的引用。（相当于给原来的对象起个别名），比如有个人叫张三，外号叫小张，对象的引用就是类似，虽然换个名字，但是两个名字指的是同一个人。

浅拷贝，拷贝的是父对象，不会拷贝到内部的子对象。（单从浅字就可以看出拷贝的东西不深，可以理解为只拷贝一层） { 1、完全切片方法；2、工厂函数，如 list()；3、copy 模块的 copy()函数 }

深拷贝，包含对象里面的自对象的拷贝（可以理解为克隆，全拷贝过去但是两者没有任何关系了，各自是各自的）；所以原始对象的改变不会造成深拷贝里任何子元素的改变 { copy 模块的 deep.deepcopy()函数 }

请阐述在Python中split()，sub()，subn()的功能分别是什么？ split()： 使用正则表达式模式将给定字符串“拆分”到列表中。

sub()： 查找正则表达式模式匹配的所有子字符串，然后用不同的字符串替换它们

subn()： 它类似于sub()，并且还返回新字符串。

**20）举例 sort 和 sorted方法的区别？** 使用 sort()方法对 list 排序会修改 list 本身,不会返回新 list，sort()不能对 dict 字典进行排序；

sorted 方法对可迭代的序列排序生成新的序列，对 dict 排序默认会按照 dict 的 key 值进行排序，最后返回的结果是一个对 key 值排序好的list；

sorted 对 tuple， dict 依然有效，而 sort 不行；

**21）解释 Python 中的可变类型和不可变类型？** 1.Python中的可变类型有list,dict；不可变类型有string，number,tuple.

2.当进行修改操作时，可变类型传递的是内存中的地址，也就是说，直接修改内存中的值，并没有开辟新的内存。

3.不可变类型被改变时，并没有改变原内存地址中的值，而是开辟一块新的内存，将原地址中的值复制过去，对这块新开辟的内存中的值进行操作。

**22）Python 中类方法、类实例方法、静态方法有何区别？** 类方法: 是类对象的方法，在定义时需要在上方使用 @classmethod 进行装饰,形参为cls，表示类对象，类对象和实例对象都可调用

类实例方法: 是类实例化对象的方法,只能由实例对象调用，形参为self,指代对象本身;

静态方法: 是一个任意函数，在其上方使用 @staticmethod 进行装饰，实例对象和类对象都可以调用。但是方法体中不能使用类或实例的任何属性和方法。

### 二. 企业面试题

**6）python新式类和经典类的区别**

在python里凡是继承了object的类，都是新式类 Python3里只有新式类 Python2里面继承object的是新式类，没有写父类的是经典类 经典类目前在Python里基本没有应用 保持class与type的统一对新式类的实例执行a.class与type(a)的结果是一致的，对于旧式类来说就不一样了。 对于多重继承的属性搜索顺序不一样新式类是采用广度优先搜索，旧式类采用深度优先搜索。 **7）python中内置的数据结构有几种**

整型 int、 长整型 long、浮点型 float、 复数 complex 字符串 str、 列表 list、 元祖 tuple 字典 dict 、 集合 set Python3 中没有 long，只有无限精度的 int **8）python如何实现单例模式?请写出两种实现方式 8.1 第一种方法:使用装饰器**

```
def singleton(cls):
    instances = {<!-- -->}
    def wrapper(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return wrapper
@singleton
class Foo(object):
    pass
foo1 = Foo()
foo2 = Foo()
print(foo1 is foo2) # True

```

## 结束语🥇🥇🥇

```
 **结束语 🥇🥇🥇**
&gt; 发现非常好用的一个刷题网站!大家一起努力！加油！！！
&gt; 题目难度可以自行选择
&gt; 在线编程出答案，（也可自行查看答案）非常方便
&gt; 程序员刷题神器网站[点击链接注册即可刷题 ](https://www.nowcoder.com/link/pc_csdncpt_bcid_python) 
&gt; 祝大家早日找到满意的工作



```
