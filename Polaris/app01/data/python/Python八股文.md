
--- 
title:  Python八股文 
tags: []
categories: [] 

---
## **py的语言特性: 动态强类型**
- 静/动态: 编绎/运行 时确定变量类型；- 弱/强类型: 会/不会发生隐式类型转换。在强类型中，不管在编译时还是运行时，一旦某个类型赋值给某个变量，它会持有这个类型，并且不能同其他类型在计算某个表达式时混合计算。
## py作为后端语言的**优缺点**：
- 语言简单灵活，开发效率高- 胶水语言，轮子多，拥有Django这种的成熟web框架- 执行效率低，性能不如其他语言- 动态语言，没有类型声明时就没有自动补全，而且很多问题要运行后才能发现
## Python常用的库

Pandas 库提供了数据整理、整理和分析这些数据科学最基本的需求。该库是能够读取、操作、聚合和可视化数据并将所有内容转换为易于理解的格式的全部内容。

NumPy被广泛用作数组处理库。由于它可以管理多维数组对象，因此它被用作多维数据评估的容器。NumPy库由一系列的元素组成，每个元素都是相同的数据类型，一个正整数的元组理想地分隔了这些数据类型。维度称为轴，而轴的数量称为等级。NumPy 中的数组被归类为ndarray。

Scikit-Learn是Python 的本地机器学习库，它为数据科学家提供以下算法：支持向量机、随机森林、K-means 聚类、光谱聚类、均值偏移、交叉验证。这是我们可以使用此 Scikit-Learn 执行的操作分类、聚类、回归、降维、数据预处理。

Matplotlib可视化可以占据了数据的关键位置，它帮助我们创建2D 图形并将绘图用到应用程序中。

Seaborn另一个数据可视化库。Seaborn 与 Matplotlib 有何不同？尽管这两个软件包都作为数据可视化软件包，但实际区别在于您可以使用这两个库执行的可视化类型。对于初学者，使用 Matplotlib，我们只能创建基本图，包括条形、线条、区域、散点图等。但是，使用 Seaborn，可视化水平提高了一个档次，因为您可以用更少的资源创建各种复杂的可视化图形。

## **1、*args、**kwargs两个参数是什么意思**

首先args，kwargs并不是必须这样设定的，只是一个约定俗成的名字，args（位置参数），kwargs（关键字参数）。 都用于函数的定义，用于将不定数量的参数传递给函数。 *args：用来发送非键值对可变数量参数，list，trump **kwargs：用来发送键值对可变数量参数，dict

## **2、谈一谈python的装饰器（decorator）**

装饰器是一个接收函数作为参数的闭包函数。它经常用于有切面需求的场景。比如：插入日志、性能测试、事务处理、缓存、权限校验等。 作用： 它能使函数的功能得到扩充，而同时不用修改函数本身的代码。 它能够增加函数执行前、执行后的行为，而不需对调用函数的代码做任何改变。

**闭包函数：**一个函数的返回值是另外一个函数，返回的函数调用父函数内部的变量，如果返回的函数在外部被执行，就产生了闭包。 闭包函数的作用：使函数外部能够调用函数内部放入属性和方法 闭包函数的优缺点：     优点：使函数外部能够调用函数内部放入属性和方法     缺点：闭包操作导致整个函数的内部环境被长久保存，占用大量内存

## **3、简要描述Python的垃圾回收机制（garbage collection）。**

python垃圾回收机制以引用计数为主，标记-清除和分代回收为辅。**引用计数：**Python在内存中存储每个对象的引用计数，对象被引用了计数加一，对象被释放了，计数减一，如果计数变成0，该对象就会消失，分配给该对象的内存就会释放出来。**标记-清除：**是一种基于追踪回收(tracing GC)技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的活动对象打上标记，第二阶段是把那些没有标记的对象非活动对象进行回收。对象之间通过引用(指针)连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象(root object)出发，沿着有向边遍历对象，可达的(reachable)对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。主要处理容器对象。**分代回收：**Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代(第0代)、中年代(第1代)、老年代(第2代)，他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。

## **4、Python多线程（multi-threading）。这是个好主意吗？**

Python并不支持真正意义上的多线程，Python提供了多线程包。 Python中有一个叫Global Interpreter Lock（GIL）的东西，它能<u>确保你的代码中永远只有一个线程在执行</u>。经过GIL的处理，会增加执行的开销。这就意味着如果你先要提高代码执行效率，使用threading不是一个明智的选择，当然如果你的代码是IO密集型，多线程可以明显提高效率，相反如果你的代码是CPU密集型的这种情况下多线程大部分是鸡肋。

## **5、os，sys有什么区别**



os模块负责程序与操作系统的交互，提供了访问操作系统底层的接口；sys模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境。

```
os 常用方法
os.remove()删除文件
os.rename()重命名文件
os.walk()生成目录树下的所有文件名
os.chdir()改变目录
os.mkdir/makedirs 创建目录/多层目录
os.rmdir/removedirs 删除目录/多层目录
os.listdir()列出指定目录的文件
os.getcwd()取得当前工作目录
os.chmod()改变目录权限
os.path.basename()去掉目录路径，返回文件名
os.path.dirname()去掉文件名，返回目录路径
os.path.join()将分离的各部分组合成一个路径名
os.path.split()返回（ dirname(),basename())元组
os.path.splitext()(返回 filename,extension)元组
os.path.getatime\ctime\mtime 分别返回最近访问、创建、修改时间
os.path.getsize()返回文件大小
os.path.exists()是否存在
os.path.isabs()是否为绝对路径
os.path.isdir()是否为目录
os.path.isfile()是否为文件
```

```
sys 常用方法
sys.argv 命令行参数 List，第一个元素是程序本身路径
sys.modules.keys() 返回所有已经导入的模块列表
sys.exc_info() 获 取 当 前 正 在 处 理 的 异 常 类 ,exc_type 、 exc_value 、
exc_traceback 当前处理的异常详细信息
sys.exit(n) 退出程序，正常退出时 exit(0)
sys.hexversion 获取 Python 解释程序的版本值， 16 进制格式如： 0x020403F0
sys.version 获取 Python 解释程序的版本信息
sys.maxint 最大的 Int 值
sys.maxunicode 最大的 Unicode 值
sys.modules 返回系统导入的模块字段， key 是模块名， value 是模块
sys.path 返回模块的搜索路径，初始化时使用 PYTHONPATH 环境变量的值
sys.platform 返回操作系统平台名称
sys.stdout 标准输出
sys.stdin 标准输入
sys.stderr 错误输出
sys.exc_clear() 用来清除当前线程所出现的当前的或最近的错误信息
sys.exec_prefix 返回平台独立的 python 文件安装的位置
sys.byteorder 本 地 字 节 规 则 的 指 示 器 ， big-endian 平 台 的 值 是'big',little-endian 平台的值是'little'
sys.copyright 记录 python 版权相关的东西
sys.api_version 解释器的 C 的 API 版本
sys.version_info 返回当前所使用的Python版本号
```

因此，sys 模块提供了一系列的函数和变量，用于操控python 的运行时环境, 而 os 提供了访问操作系统底层的接口。

## **6、什么是lambda表达式？它有什么好处？**

简单来说，lambda表达式通常是当你需要使用一个函数，但是又不想费脑袋去命名一个函数的时候使用，也就是通常所说的<u>匿名函数</u>。

lambda表达式一般形式是：关键词lambda后面紧接一个或多个参数，紧接一个冒号“：”，紧接一个表达式。lambda表达式是一个表达式不是一个语句。

## **7、pass语句有什么作用**

pass语句不会执行任何操作，一般作为占位符或者创建占位程序。

## **8、Python里面如何拷贝一个对象？**

直接赋值：Python中对象之间的赋值是<u>按引用</u>传递的，不会开辟新的内存空间。如果要拷贝对象需要使用标准模板中的copy。

copy.copy：浅拷贝，只拷贝父对象，不拷贝父对象的子对象，它的子对象还是原对象中的子对象。 copy.deepcopy：深拷贝，拷贝父对象和子对象。深拷贝会递归地拷贝原对象中的每一个子对象，因此拷贝后的对象和原对象互不相关。



## **9、__new__和__init__的区别。**

__init__为初始化方法，__new__方法是真正的构造函数。 __new__是实例创建之前被调用，它的任务是创建并返回该实例，是静态方法 __init__是实例创建之后被调用的，然后设置对象属性的一些初始值。

总结：__new__方法在__init__方法之前被调用，并且__new__方法的返回值将传递给__init__方法作为第一个参数，最后__init__给这个实例设置一些参数。

## **10、Python中单下划线和双下划线分别是什么。**

__name__：一种约定，Python内部的名字，用来与用户自定义的名字区分开，防止冲突 _name：一种约定，用来指定变量私有 __name：解释器用_classname__name来代替这个名字用以区别和其他类相同的命名

## **11、什么是生成器?**

生成器是一种可迭代对象，可以挂起并保持当前的状态。

生成器遇到yield处会停止执行，调用next()或send()才会继续执行。。

定义一个生成器有两种方式，一种是生成器推导式，一种是在普通函数中添加yield语句并实例化。

## **12、什么是元类? 使用场景**

**元类**是创建类的类，type还有继承自type的类都是元类。作用: 在类定义时（new, init）和类实例化时(call) 可以添加自定义的功能。

**使用场景: **ORM框架中创建一个类就代表数据库中的一个表，但是定义这个类时为了统一需要把里面的类属性全部改为小写，这个时候就要用元类重写new方法，把attrs字典里的key转为小写。

## **13、collections模块**

collections模块提供了一些好用的容器数据类型，其中常用的有: namedtuple，deque，Counter，OrderedDict，defaultdict

## **14、为什么dict查找的时间复杂度是O(1)?**

dict底层是哈希表，哈希表类似于C语言的数组，可以实现按索引随机访问

但dict的key不一定是整数，需要先通过哈希函数，再经过取余操作转换为索引

## **15、list tuple的底层结构**

list和tuple底层都是顺序表结构。list底层是可变数组，数组里存放的是元素对象的指针。

列表用中括号表示，是可变序列，它的元素可以随时进行增删改；元组用括号表示，是**不可变**序列，元组比列表访问和处理速度快。

## **set的底层结构**

哈希表，key就是元素，value都是空

## **16、class方法 和 static方法的区别**

class方法的第一个参数是cls，可以访问类属性、类方法；

static方法和普通函数一样，只不过是放在类里，要通过类或实例来调用，但是它不能访问类和实例的属性和方法。

## **17、说一说Python自省**



自省是指通过一定的机制查询到对象的内部结构，在python中一切皆对象，我们能通过自省机制得到对象的类型内部的属性。**常用函数：**
- **dir()函数**，返回 一个列表，包含对象所有属性和方法。- **id()函数**，用于返回一个对象的内存地址。- **type()函数**，用于放回一个对象的类型。- **hasattr()函数**，用于测试对象是否具有某个属性。- **getattr()函数**，用于获取对象某个属性。- **isinstance() **函数测试对象，以确定它是否是某个特定类型或定制类的实例
## python中的is和==区别



python是一种面向对象的语言，python中对象包含三种基本要素：id(返回的是对象的地址)、type(返回的是对象的数据类型)及value(对象的值)。

is比较的是两个对象的地址值，也就是说两个对象是否为同一个实例对象；而==比较的是对象的值是否相等，其调用了对象的__eq__()方法。

**参考文章：**



、
