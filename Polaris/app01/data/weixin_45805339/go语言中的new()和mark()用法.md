
--- 
title:  go语言中的new()和mark()用法 
tags: []
categories: [] 

---
### Go语言内存分配机制

Go语言有两种分配内存的机制new()和make(),我们简单分析一下两种机制的不同

#### new函数

new()函数可以给一个值类型的数据分配数据内存，调用成功后返回一个初始化的内存块指针，原型定义如下：

```
func new(Type) * Type

```

在调用new()函数时要注意，参数Type是一个类型而不是具体的数值，函数调用成功后返回该类型的内存指针，同时该类型被初始化为“0”值。 new是一个分配内存的内置函数，但不同于其他语言中new所作的工作，它只是将内存清零，而不是初始化内存。比如new(T)为一个类型为T的新项目分配了值为零的存储空间并返回其地址，也就是一个类型为*T的值。返回了一个指向新分配的类型为T的零值的指针。

#### make函数

make()函数用于给引用类型分配内存空间，像Slice、Map、Channel等。需注意的是make()函数创建的是一个引用类型对象，而不是一个内存空间的指针。原型定义如下：

```
func make(Type,size IntegerType) Type

```

在调用make()函数时，参数Type必须是一个引用类型（Slice、Map或Channel）；参数IntegerType指定要创建的该对象的个数。和new()函数不同的是，make()函数调用成功后返回的是一个对象，而非是一个内存空间的指针，即到底要分配多少内存由该对象的大小和个数来决定。

```
make([]int,10,100)

```

分配了一个整形数组，长度为10，容量为100，并返回前10个数组的切片。

#### 比较new()函数和make()函数的不同

```
# 使用new()函数为切片结构分配内存，*p = = nil,在实际设计中这种用法很少使用
var p * []int = new([]int)
# 使用make()函数创建了一个有10个整数元素的数组的Slice对象。
var v []int = make([]int,10)

```

#### 总结

make(T,args)函数的目的与new(T)函数不同。它仅用于创建Slice、Map和Channel，并返回类型T(不是*T)的一个被初始化了的（不为零）实例。这种差别的出现是由这三种类型实质上是对在使用前必须进行初始化的数据结构的引用。例如，Slice是一个具有三项内容的描述符，包括指向的数据（在一个数组内部）的指针、长度以及容量，在这三项内容初始化之前，Slice值为nil。对于Slice、Map和Channel，make()函数初始化了其内部的数据结构并准备了将要使用的值。
