
--- 
title:  Go与C/C++中的堆和栈比较 
tags: []
categories: [] 

---
首先我们确定一点不管是Go还是C/C++都有堆和栈的概念，我们今天说的是它们到底有何不同，有什么区别。

### C/C++ 中的堆和栈
- C/C++中提及的“程序堆栈”本质上其实是操作系统层级的概念；- 它通过C/C++语言的编译器和所在环境来共同决定；- 在程序启动时，操作系统会自动维护一个所启动程序消耗内存的地址空间，并自动将这个空间从逻辑上划分为堆内存空间和栈内存空间。这时，“栈”的概念是指程序运行时自动获得的一小块内存，而后续的函数调用所消耗的栈大小，会在编译期间由编译器决定，用于存储局部变量或者保存函数调用栈；- 如果在C/C++中声明一个局部变量，则会执行逻辑上的压栈操作，在栈中记录局部变量。而当局部变量离开作用域之后，所谓的自动释放本质上是该位置的内存在下一次函数调用压栈的过程中，可以被无条件的覆盖；- 对于堆而言，每当程序通过系统调用向操作系统申请内存时，会将所需的空间从维护的堆内存地址空间中分配出去，而在归还时则会将归还的内存合并到所维护的地址空间中。
### Go中的堆和栈
- go程序也是运行在操作系统上的，自然也有前面提及的堆和栈的概念- 区别在于传统意义上的“栈”被Go语言的运行时全部消耗了，用于维护运行时各个组件之间的协调，例如：调度器、垃圾回收、系统调用等- 对于用户态的Go代码而言，它们消耗的“堆和栈”，其实只是Go运行时通过管理向操作系统申请的堆内存，构造的逻辑上的“堆和栈”，他们的本质都是从操作系统申请而来的堆内存；- 由于用户态Go程序的“栈空间”是由运行时管理堆内存得来，相较于只有1MB的C/C++中的“栈”而言，Go拥有“几乎”无限的栈内存（1GB）；- Go语言运行时为了防止内存碎片化，会在适当的时候对整个栈进行深拷贝，将其整个复制到另一块内存区域（当然，这个过程对用户态的代码是不可见的），这也是相对于传统意义上的栈是一块固定分配好的内存所出现的另一处差异。也正是由于这个特点的存在，指针的运算不能再奏效，因为在没有特殊说明的情况下，无法确定运算前后指针所指向的地址的内容是否已经被Go运行时移动。