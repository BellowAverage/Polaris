
--- 
title:  【LeetCode每日一题】189. 轮转数组——公式数学（C/C++） 
tags: []
categories: [] 

---
>  
 年轻这个借口，不知道还能用多久！ 


### 题目：

给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。

### 示例 1:

输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右轮转 1 步: [7,1,2,3,4,5,6] 向右轮转 2 步: [6,7,1,2,3,4,5] 向右轮转 3 步: [5,6,7,1,2,3,4]

### 示例 2:

输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100] 解释: 向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100]

### 提示：

1 &lt;= nums.length &lt;= 105 -231 &lt;= nums[i] &lt;= 231 - 1 0 &lt;= k &lt;= 105

### 进阶：

尽可能想出更多的解决方案，至少有 三种 不同的方法可以解决这个问题。 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？

### 思路：

首先看到这道题，我想得是用链表，可在刚刚敲代码时，突然意识到一行公式就可以解决啊，看下面： 首先用 **size()** 函数获取数组长度n； n个数字在有序空间“流动”k次，每个数字向后移动k的距离，即 i + k ，但超过空间长度咋办呢，那就取余吧，对空间长度取余 即：（i + k）% n 。 可获得如下公式：**nums[(i+k) % n] = a[i];**

### 代码：

```
void rotate(vector&lt;int&gt;&amp; nums, int k) {<!-- -->
    int n = nums.size();
    vector&lt;int&gt; a(nums);
    for(int i = 0; i &lt; n; i++){<!-- -->
    	nums[(i+k) % n] = a[i];
	}
}

```

来源：力扣（LeetCode） 链接：
