
--- 
title:  Shell脚本学习笔记 
tags: []
categories: [] 

---
## Shell脚本学习笔记

该笔记根据组团学提供的摘录和个人理解所作笔记，仅作学习记录。（完整内容可点击链接跳转，其中有其它很多很好的学习资源） 

#### 文章目录
- - <ul><li>- - - - - - - - - - - 


### 一、Shell简介

shell是一个程序，采用C语言编写，是用户和Linux内核沟通的桥梁。它既是一种命令语言，又是一种解释型编程语言。

Shell脚本就是将完成一个任务的所有的命令按照执行的先后顺序，自上而下写入到一个文本文件中，然后给予执行权限。

关键词： `命令语言` ` 解释型语言` ` 顺序执行` `执行权限`

### 二、Shell脚本编写模板

`template.sh`

```
#!/usr/bin/bash

# Name：Template
# Author: Yanis
# Create Time: 2022/08/03 12:00
# Update Time: null
# Release: 1.0
# Description: Shell Template
# Usage: ./template.sh


commands

```

解释说明：`#!/usr/bin/bash` 为脚本的执行环境定义，必须以`#!` 开头，这个是Shell脚本的固定语法，其中`/usr/bin/bash` 为执行环境所在路径，因为Shell也是解释型语言，所以执行环境也可称解释环境。

也有另一种写法：`#!/usr/bin/env bash` ，语法是：固定开头`#!/usr/bin/env ` +空格隔开+解释环境（`bash` 或`python` 或 `perl` 等等），对比如下：

》`#!/usr/bin/bash ` &lt;=&gt; `#!/usr/bin/env bash` ==&gt; 文件后缀：`.sh`

》`#!/bin/python ` &lt;=&gt; `#!/usr/bin/env python` ==&gt; 文件后缀：`.py`

注释符：`#` ，可以使用多个`####...####` 进行代码区分，仅是代码风格，仅适用于单行注释

脚本组成：

​ 1）解释环境：`#!/usr/bin/env bash`

​ 2）注释说明：` 脚本的基本信息以及关键命令的解释，尽量使用英文，中文可能会引发异常`

​ 3）执行代码：` 完成一个任务的所需命令以及辅助代码`

风格规范：

​ 1）脚本命名：`xx.sh` ，不宜太长，长度少于26个字节

​ 2）代码规范：参见上述模板

### 三、Shell脚本运行

1、给予执行权限（**推荐使用**）

```
chmod +x tamplate.sh    或者 chmod 755 tamplate.sh
./tamplate.sh           绝对路径或相对路径均可

```

注意：该方法在执行前必须赋予执行权限(x)，否则需使用下面第二种方法。权限一般设置744,755,700

2、使用解释器直接运行，不需要给权限（不建议使用）

```
bash ./tamplate.sh  

```

### 四、Shell脚本常用命令

**1、Linux中的常用符号**

|字符|含义
|------
|*|代表任意字符串，匹配所有
|？|代表任意字符，匹配除回车以外的一个字符
|/|代表根目录或作为路径间隔符使用
|\|转义字符。
|&lt;ENTER&gt;|续行符。可以使用续行符将一个命令行分写在多行上
|$|变量值置换，如：$PATH表示环境变量PATH的值
|’ ’|单引号，在’…'中间的字符都会被当做普通字符处理，不解释变量
|" "|双引号，在"…"中间的字符会被当做文字处理并允许变量值置换。
|` `|反引号，命令中执行命令，echo “today is `date +%F`.”
|&lt;|输入重定向字符
|&gt;|输出重定向字符
|&gt;&gt;|追加输出
|&lt;&lt;|追加输入
|||管道字符，上一个命令的输出，作为下一个命令的输入
|&amp;|后台执行字符。在一个命令之后加上字符“&amp;”，该命令就会以后台方式执行
|;|按照顺序执行的多个命令
|()|在子Shell中执行命令
|{}|在当前Shell中执行命令
|!|执行命令历史记录中的命令
|~|代表登录用户的宿主目录（自家目录）

输入输出重定向与合并的用法有

|语法|作用
|------
|cmd &lt; file|从file重定向标准输入
|cmd &gt; file|把标准输出重定向到file中，如果file存在的话，覆盖（损坏）它
|cmd&gt;&gt;file|把标准输出重定向到file中，如果file存在，附加给它
|cmd 2&gt;file|把标准错误重定向到file，如果file 存在，覆盖（损坏）它
|cmd 2&gt;&gt; file|把标准错误重定向到file中，如果file 存在，附加给他
|cmd&gt;file 2&gt;&amp;1|合并标准输出和标准错误，并且重定向到file中（可移植的语法）
|cmd &gt;&amp; file|合并标准输出和标准错误，并且重定向到file中（方便的语法）

**2、Shell的常用数据处理命令 **

```
数据检索命令
    行检索：grep  egrep
    字符串检索:cut  tr
数据处理命令       
	数据排序：sort
  	数据去重: uniq
  	文本数据合并: paste
  	数据输出: tee
  	数据处理: xargs   

```

**3、Shell脚本格式化输出 echo**

echo命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。 功能说明:显示文字。

语法：echo输出默认最后换行且不处理转移字符，-n 表示最后不换行，-e 表示处理转义字符

```
echo [-n] [-e] "字符串"

```

转移字符：

```
\a	`发出警告声;`
\b	`删除前一个字符;`
\t	`插入tab;`
\n	`换行且光标移至行首;`

\c	`最后不加上换行符号;`
\f	`换行但光标仍旧停留在原来的位置;`
\r	`光标移至行首，但不换行;`
\v	`与\f相同;`
\		`插入\字符;`
\0nnn	`打印nnn(八进制)所代表的ASCII字符;  备注：数字0  不要理解成字母o`
\xNN  `打印NN(十六进制)所代表的ASCII字符;`

```

输出颜色字体：

脚本中echo显示内容带颜色显示,echo显示带颜色，需要使用参数-e

语法：字符串与m之间的空格也会被输出

```
echo -e "\033[字背景颜色;文字颜色m字符串\033[0m"

```

下面是相应的字和背景颜色，可以自己来尝试找出不同颜色搭配

```
字颜色：30—–37
　　echo -e "\033[30m 黑色字 \033[0m"
　　echo -e "\033[31m 红色字 \033[0m"
　　echo -e "\033[32m 绿色字 \033[0m"
　　echo -e "\033[33m 黄色字 \033[0m"
　　echo -e "\033[34m 蓝色字 \033[0m"
　　echo -e "\033[35m 紫色字 \033[0m"
　　echo -e "\033[36m 天蓝字 \033[0m"
　　echo -e "\033[37m 白色字 \033[0m"
　　
字背景颜色范围：40—–47
　　echo -e "\033[40;37m 黑底白字 \033[0m"
　　echo -e "\033[41;37m 红底白字 \033[0m"
　　echo -e "\033[42;37m 绿底白字 \033[0m"
　　echo -e "\033[43;37m 黄底白字 \033[0m"
　　echo -e "\033[44;37m 蓝底白字 \033[0m"
　　echo -e "\033[45;37m 紫底白字 \033[0m"
　　echo -e "\033[46;37m 天蓝底白字 \033[0m"
　　echo -e "\033[47;30m 白底黑字 \033[0m"
　　
最后面控制选项说明
　　\033[0m 			"关闭所有属性"
　　\033[1m 			"设置高亮度"
　　\033[4m 			"下划线"
　　\033[5m 			"闪烁"
　　\033[7m 			"反显"
　　\033[8m 			"消隐"
　　\033[30m — \33[37m  "设置前景色"
　　\033[40m — \33[47m  "设置背景色"
　　\033[nA 			"光标上移n行"
　　\033[nB 			"光标下移n行"
　　\033[nC 			"光标右移n行"
　　\033[nD 			"光标左移n行"
　　\033[y;xH 		"设置光标位置"
　　\033[2J 			"清屏"
　　\033[K 			 "清除从光标到行尾的内容"
　　\33[s 			"保存光标位置"
　　\033[u 			"恢复光标位置"
　　\033[?25l 		"隐藏光标"
　　\033[?25h 		"显示光标"

```

**4、Shell脚本用户交互——用户输入read**

read命令默认接受键盘的输入，回车符代表输入结束。

命令选项：

```
-p	打印信息，相当于在read前echo    read -p "Password:"
-t	限定时间，单位：秒              read -t50
-s	不回显，不显示输入内容          read -s
-n	输入字符个数，达到后自动结束输入 read -n6
变量名   输入信息将赋值给变量名      read password

```

### 五、Shell变量

**1、定义一个变量 **

格式：`变量名=值` ，在Shell编程中，变量名与等号之间不能有空格

变量命名规则：

​ 1）命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。

​ 2）等号两端不能有空格，可以使用下划线（_）。

​ 3）不能使用标点符号和bash里的关键字（可用–help选项查看保留关键字）。

​ 4）变量名一般大写，字符串可使用单引号或双引号，只是单引号不解释变量。

**2、变量分类**

本地变量：临时变量，临时定义在脚本或当前终端的变量，不互通，脚本或终端结束失效。`name=12`

环境变量：定义在用户家目录下的`~/.bashrc`或`~/.bash_profile`文件中，仅当前用户可用，Shell启动后自动生效，当前Shell（终端）下所有进程可用，重启仍然有效，在Shell启动后临时创建的，重启失效。使用：`export name=12 ` ，查看命令：`env` 或 `set`

全局变量：与环境变量类似，全局所有的用户和程序都能调用，且继承，新建的用户也默认能调用。

内置变量：系统变量(内置bash中的变量) ，shell本身已经固定好了它的名字和作用.

```
1) $?：上一条命令执行后返回的状态，`当返回状态值为 0 时表示执行正常`，#非0值表示执行异常或出错
 `若退出状态值为 0，表示命令运行成功`
 若退出状态值为 127,表示command not found
 若退出状态值为 126,表示找到了该命令但无法执行（权限不够）
 若退出状态值为 1&amp;2,表示没有那个文件或目录
2) $$：当前所在进程的进程号     echo $$   eg：kill -9 `echo $$`  = exit   退出当前会话
3) $!：后台运行的最后一个进程号  （当前终端）   gedit &amp;
4) !$ 调用最后一条命令历史中的参数
5) !! 调用最后一条命令历史
6) $#：脚本后面接的参数的个数
7) $*：脚本后面所有参数，参数当成一个整体输出，每一个变量参数之间以空格隔开
8) $@: 脚本后面所有参数，参数是独立的，也是全部输出
9) $0：当前执行的进程/程序名  echo $0     
10) $1~$9 位置参数变量
11) ${10}~${n} 扩展位置参数变量  第10个位置变量必须用{<!-- -->}大括号括起来

```

|变量类型|作用域|生命周期
|------
|本地变量|当前终端或脚本|脚本结束或终端结束
|环境变量|当前Shell及其子进程|当前Shell结束
|全局变量|所有用户及shell环境|关机
|内置变量|所有用户及shell环境|关机

**3、变量应用**

**① 获取变量值**

格式：`$变量名 `

在字符串中解释变量： `"$变量名"` 或 `eval ... '$变量名'`

例如 ：`name=12`

取值： `echo $name ` 或 `echo "$name"` 或 `eval echo '$name' `

**② 取消当前环境中变量—unset **

取消当前环境（终端或脚本）中的变量，如果是变量设置是保存在文件中，下次重启又会恢复

格式：`unset 变量名`

**③ 声明变量类型—declare**

可以在声明变量类型的同时给变量赋值，也可以对已赋值的变量进行类型声明。

整型 变量：`declare -i 变量名[=值] ` ，[ ]表示可选，下同

只读 变量：`declare -r 变量名[=值]` ，该变量的值无法改变，并且不能为unset

环境 变量：`declare -x 变量名[=值] ` ， 等价于 export ，且export也是调用declare -x

数组 变量：`declare -a 数组名 ` 或 `declare -A 数组名`

​ -a 声明为索引数组； -A 声明为字典数组；

查看指定类型的所有变量：以上五种变量类型中，不加变量名则是查看当前类型的所有变量

查看所有变量或指定变量的类型： `declare -p [变量名]`

**④ 数组变量 **

数组介绍：数组可以让用户一次赋予多个值，( ) 表示数组，数组中元素之间用`空格`隔开。

​ 1）索引数组：使用 整数 作为数组索引，定义：`数组名=(元素1 元素2 元素3 ...)`

​ 2）关联数组：使用 字符 作为数组索引，定义：`数组名=([键名1]=值1 [键名2]=值2 [键名3]=值3 ...)`

数组赋值方式：索引数组赋值前无需声明，关联数组赋值前必须先声明变量类型 -A。

​ 1）一次赋予一个值

​ 索引数组：`数组名[索引号]=值` ，索引号从0开始。

​ 关联数组：`数组名[键名]=值` ，键名为字符串，可不加单双引号。

​ 2）一次赋予多个值

​ 索引数组：`array=(var1 var2 var3 var4)`

​ 关联数组：`array=([key1]=12 [key2]="jack" [key3]="amy")`

数组取值方式：

​ 1）索引数组：`${数组名[索引号]}` ，可以使用@ 或 * 来获取数组中的所有元素。

```
${array[i]}          获取第i个元素
${array[*]}          获取数组里所有元素， * 可用 @ 代替
${<!-- -->#array[@]}         获取数组里的元素长度，@ 可用 * 代替
${<!-- -->!array[*]}         获取数组里所有元素的索引号， * 可用 @ 代替
${array[@]:i:n}      获取指定范围的元素，1:2 代表从索引为1的元素开始读取2个元素,a[i]...a[i+n-1]

```

​ 2）关联数组：`${数组名[键名]}` ，可以使用@ 或 * 来获取数组中的所有元素。

```
${array[key]}        获取键名为key的元素
${array[*]}          获取数组里所有元素， * 可用 @ 代替
${<!-- -->#array[@]}         获取数组里的元素长度，@ 可用 * 代替
${<!-- -->!array[*]}         获取数组里所有元素的键， * 可用 @ 代替

```

**⑤ 变量匹配 **

1）取出一个路径下的目录和文件：dirname和 basename

```
A=/root/Desktop/shell/mem.txt
dirname $A   取出目录
输出：`/root/Desktop/shell`
basename $A  取出文件
输出：`mem.txt`

```

2）变量"内容"的删除和替换 ​ “%” ：代表忽略末尾第一个匹配内容，不含匹配符

​ “%%”：代表仅保留开头的一个匹配内容，不含匹配符

​ “#” ：代表忽略开头第一个匹配内容，不含匹配符

​ “##” ：代表仅保留末尾的一个匹配内容，不含匹配符

```
url=www.taobao.com
echo ${<!-- -->#url}         获取变量的长度
输出：14
echo ${url#*.}       以分隔符.界限，忽略开头到第一个.的内容
输出：taobao.com
echo ${url##*.}      以分隔符.界限，仅保留最后一个.到末尾的内容
输出：com
echo ${url%.*}       以分隔符.界限，忽略末尾到最后一个.的内容
输出：www.taobao
echo ${url%%.*}      以分隔符.界限，仅保留开头到第一个.的内容
输出：www

```

### 六、Shell运算符与运算规则

1、赋值运算符： `=` ；

2、逻辑运算符：

```
&amp;&amp;      与运算, 不能在命令行使用，-a 可以代替，适用于多条逻辑表达式
||      或运算, 不能在命令行使用，-o 可以代替，适用于多条逻辑表达式
!       非运算，只适用于单条逻辑表达式。

```

3、算术运算：

​ 算术运算符：`+ - * /` ：加减乘除； ` %` ：取余 ； `**` ：幂运算

​ 运算命令：`expr ` , `let` , `$(( ))` &lt;–前三种仅适用整型运算, `bc` &lt;–适用于整型和浮点型运算，需要安装

```
expr n [+ - \* / % ] m       *应进行转义 \*，运算符两端应有空格，不支持**
let a=n [+ - * / % **]m      只适用于变量（a），可以使用 [++ -- -= +=]，无空格格式限制
$((n [+ - * / % **] m))      当前形式仅适用于整数运算，无空格格式限制
echo "scale=N;运算表达式"|bc  scale的N表示最大保留N位小数，小数后的无效0会被舍弃，表达式中支持浮点数

```

4、比较运算：True 返回为 0 ，False 返回 1 。比较运算符与值之间应用空格隔开，支持变量比较。

​ 整数比较：

```
-eq     等于            10 -eq 10
-ne     不等于          10 -ne 11
-gt     大于            10 -gt 9
-lt     小于            10 -lt 11
-ge     大于或等于       10 -ge 9
-le     小于或等于       10 -le 11

```

​ 字符串比较运算符：单词可以不加" "。

```
==      等于					 "str1"  == "str2"
!=      不等于				 $str   != "abc"
-n      判断字符串是否非空		-n "str"
-z      判断字符串是否为空       -z "str"

```

​ 文件比较：文件路径无需引号

```
-d  	 检查路径是否存在且为目录				-d Path    例：-d /usr/local
-e  	 检查路径是否存在				       -e Path
-f  	 检查路径是否存在且为文件				-f Path
-S  	 socket
-p  	 检查文件是否存在且为FIFO文件pipe        -p File
-c  	 检查文件是否存在且为字符文件            -c File
-b  	 检查文件是否存在且为块文件block         -b File
-L  	 检查文件是否存在且为软连接文件link      -L File
-r  	 检查文件是否存在且可读				 -r File
-s  	 检查文件是否存在且不为空				-s File
-w  	 检查文件是否存在且可写				 -w File
-x  	 检查文件是否存在且可执行				-x File
-u  	 是否有suid
-g  	 是否sgid
-k  	 是否有t位
-O  	 检查文件是否存在并且被当前用户拥有		 -O File
-G  	 检查文件是否存在并且默认组为当前用户组	-G File
-nt		 检查File1是否比File2新		File1 -nt File2
-ot		 检查File1是否比File2旧		File1 -ot File2
-ef		 检查File1是否与File2是同一个文件，判定依据的是i节点  File1 -ef File2

```

### 七、if 判断语句和case选择语句

**1、if 判断语句**

语法格式：可以没有 elif 和 else 部分，else适用于2层以上，elif 适用于3层以上，then 有两种写法，与 if 同行，则需要加 `;` 和空格，不同行，则不需要 `;` 。if 里面可以嵌套 if 语句。条件表达式用 [ ] 括起来，且与条件之间用空格隔开。也可使用test命令，两者等效

```
if [ 条件1 ]; then
  执行命令1
elif [ 条件2 ]
  then
    if [ 条件3 1 ] &amp;&amp; [ 条件3 2 ]; then
      执行命令2
    else
      执行命令3
    fi
else
  执行命令4
fi

```

if 高级用法

​ 1）条件符号使用双圆括号，可以在条件中植入数学表达式 if (( (5+5-5)*5/5 &gt; 10 ))，使用数学比较符

​ 2）使用双方括号,可以在条件中使用通配符，多用于字符串匹配 if [[ “$var” == r* ]]

**2、case选择语句**

case语句与C语言编程中的switch…case语句相似。

语法格式：每个模式

```
case $var in                           定义变量，var表示变量名
p1) command1 ;;                        p1表示$var的可能值之一，可以使数字或字符，[0-9]
p2 | p3) command2 ;;                   多个匹配模式则用 | 分隔，相当于or
p4) command3                           command也可以是函数 
    command4 ;;                        ;; 表示当前匹配的结束, 遇到才结束
*) default command ;;                  *) 如果没有匹配，则默认输出        
esac

```

### 八、循环语句

**1、for 循环**

​ 基本语法格式：

```
for var in list; do           
   commands
done

#list 的形式：
1）{<!-- -->1..10} 或 {<!-- -->0..10..2} 或 {<!-- -->10..1} 或 {<!-- -->10..1..-2}
2) 1 2 3 4 或 a b c d
3) `seq 10` 或 `seq 1 9` 或 `seq 0 2 10` 或 `seq 10 -2 1` 
4）当省略 in list时，由用户指定参数和参数的个数

```

​ C语言语法格式：支持多变量，条件为真时才执行循环

```
for(( i=1,j=2;i&lt;5;i++,j-- ));do
  commands
 done

```

**2、while 循环**

语法格式：一般需要一个变量来控制循环的结束与否，条件为真时才执行循环

```
i=1
while [ 表达式 ] ; do
  commands
  let i++
done

当[ 表达式] 为 : 或 true 时 ，属于无限循环 while : 或 while true； while false 则不执行循环。

```

**3、until 循环**

语法格式：条件为假时才执行循环，条件为真时结束循环。

```
until [ 表达式 ] ; do
  commands
done

```

循环中常用特殊命令和语句：

```
break            终止循环
continue         跳过本次循环
exit 0           结束脚本 ，0为正常退出，1为异常退出
sleep N          循环等待时间，休眠 N 秒
shift N          循环参数控制，默认每次获取1个参数，构成循环体中的参数列表，因此在循环中$1会更新
seq 9 | seq 1 9  或 seq  9 -2 1    生成一个 数字列表1-9，或 9到1之间每次减2的数字列表
[commands] 1&gt;/dev/null     命令commands执行成功
[commands] 2&gt;/dev/null     命令commands执行失败

```

常用特殊变量：

```
$USER           获取当前用户名

```

### 九、Shell函数

shell中允许将**一组命令集合**或**语句**形成一段**可用代码**，这些代码块称为shell函数。

语法格式：

```
# 语法一
函数名 () {<!-- -->
  代码块
  echo 任意结果
  return N
}

# 语法二
function 函数名 {<!-- -->
  代码块
  echo 任意结果
  return N 
}

# 函数值返回值说明：
1）return 可以提前结束函数，也可返回0-256之间的指定数值，不指定则默认返回最后一个命令的退出状态。
2）echo 通常用于返回所需数据，不会提前结束函数，多个echo 会当做一个序列返回，
3）return 用于返回函数的执行状态（条件表达式判断），echo用于返回函数中得到的结果（返回值给变量），echo必须return前使用，读取函数echo返回值：`函数名 参数` 或者 $(函数名 参数)，此时echo内容不会输出到终端，当直接使用函数名时，则echo内容会输出到终端。
4) 若函数没有返回值，函数将返回最后一个Shell的退出值，或者可以使用return $?

```

### 十、正则表达式

1、正则表达式的介绍

**正则表达式**（Regular Expression、regex或regexp，缩写为RE），也译为正规表示法、常规表示法，是一种字符模式，用于在查找过程中匹配指定的字符。

**支持正则表达式的程序如：locate |find| vim| grep（egrep）| sed |awk**

2、正则表达式的特殊字符

```
` 定位符：匹配开头和结尾`
^       以什么开头，只对一个字符(组)定位    匹配以a开头：egrep "^a" datafile   
$       以什么结尾，只对一个字符(组)定位    匹配以c结尾：egrep "c$" datafile
        当同时使用 "^ $" 时，则精确匹配

` 匹配符：匹配字符串内容`
.        匹配除回车以外的任意一个字符           egrep "^a.*c$" datafile    a开头c结尾
( )      字符串组，解决定位符的单子配对问题      egrep "^(ab)" datafile    ab开头
[ ]      定义字符类，匹配括号中的一个字符        egrep "^a[a-z0-9A-Z]" datafile
[^ ]     表示否定括号中出现字符类中的字符，取反   egrep "^a[^a-z]c$" datafile
\        转移字符，对匹配符进行转移成字符内容     egrep "^a\.c$" datafile   .作为普通字符
|        或，逻辑式                           egrep "(b|c)$" datafile  b或c结尾
\d\w\s   匹配数字、字符、空格
\D\W\S   匹配非数字、非字符、非空格
.*       匹配所有内容

` 限定符：规定对限定符前面的字符(串)的连续出现次数`
*       字符(串)连续出现次数 &gt;=0                egrep "^ab*c$" file
?       字符(串)连续出现次数 =0或1              egrep "^ab?c$" file 
+       字符(串)连续出现次数 &gt;=1                egrep "^ab+c$" file
{<!-- -->n}     字符(串)连续出现次数 =n                 egrep "^ab{3}c$" file
{<!-- -->n,}    字符(串)连续出现次数 &gt;=n                egrep "^ab{1,}c$" file
{<!-- -->n,m}   字符(串)连续出现次数 n=&lt; x &lt;=m          egrep "^ab{2,4}c$" file

` POSIX字符：表示一个范围的特殊字符，一次只匹配一个范围中的一个字节，需另外与[]匹配度配合使用`
[:alnum:]	 匹配任意字母字符0-9 a-z A-Z      egrep "^a[[:alnum:]]c$" file
[:alpha:]	 匹配任意字母，大写或小写          [[:alpha:]]  ==  [a-zA-Z]
[:digit:]	 数字 0-9                      
[:graph:]	 非空字符( 非空格控制字符)         
[:lower:]	 小写字符a-z
[:upper:]	 大写字符A-Z
[:cntrl:]	 控制字符
[:print:]	 非空字符( 包括空格)
[:punct:]	 标点符号
[:blank:]	 空格和TAB字符
[:xdigit:]	 16 进制数字
[:space:]	 所有空白字符( 新行、空格、制表符)

```

### 十一、Shell对文件的操作-sed

**1、sed命令介绍**

sed是行编辑器，内容在内存中编辑，然后输出到屏幕，也可以对文本进行增删改查且是非交互式的。

sed命令的作用：非交互式对文本增删改查

非交互式就是不用人为打开一个文本文件，然后修改其中的内容，只需要给定操作，让程序去修改文件。

**2、sed语法**

语法格式：

```
sed [options] '{command}[flags]' [filename]

` options`
-e         将脚本中指定的命令添加到处理输入时执行的命令中  多命令执行(;隔开)
-f         将文件中指定的命令添加到处理输入时执行的命令中
-n         抑制内存的输出，避免重复输出
-i         编辑文件内容
-i.bak     修改时同时创建.bak备份文件，bak可为其它名称。
-r         使用扩展的正则表达式
!          取反 （跟在模式条件后与shell有所区别）

`command   对文件的操作,默认以除匹配内容外的第1个字符当做命令`
a    在匹配行后面添加一行内容        '//a插入内容'
i    在匹配行前面插入一行内容        '//i插入内容'
d    删除匹配行                     '//d'
s    查找替换匹配行中的部分字符串     '//s/查找内容/替换内容/'   查找内容支持正则表达式，替换可留空
c    更改匹配行的全部内容            '//c插入内容'
y    字符转换，替换匹配行中指定字符   '//y/查找字符(abc)/替换字符(ABC)/'  #字符一一对应替换
p    打印匹配内容                    '//p'
=    打印匹配内容的行号               '//='
r file         将文件file的内容追加到操作文件匹配行后,对a的多行添加  '//r file'

` flags：可多个标志`
N              N为&gt;1的数字，对第N个匹配内容进行操作     与s使用，默认只替换第一个字符串
g              表示全部替换匹配内容                    与s使用，全部替换，N/g不可同时使用
p              表示打印原始的内容                      与aidscy均可使用，与p命令相同
w file         将操作结果或匹配行写入新文件file         与命令搭配或单独使用均可，可使用匹配

```

**3、sed应用**

```
` 匹配行`
 `对第几行操作，若不加行号和匹配内容，则对每一行都执行相同的操作。`
	'2a','2i','1d','3s','4c','5y','6p' ,'2w file' ,'4r file'
 `对第几行到第几行一个范围的行操作，分别对每一行执行相同的操作`
	'2,4a','2,4i','1,5d','3,6s','4,9c','5,7y','6,8p' 
 ` $ 表示最后一行 `
	'$a','$i','$d','$s','$c','3,$y','$p' 
 `'n~m' 表示从第n行开始，每隔m行操作一次，n，n+2m，n+3m..的行都会被匹配`
	'1~2a','1~2i','3~2d','2~2s','1~2c','4~2y','1~2p' 
 `按内容匹配行(包含//中的字符串的行)，匹配的所有行都执行相同的操作`
 `若//中内容是正则表达式(-r '/^(the)/p')，则需要添加 -r 选项，否则按内容匹配`
	'/hello world/a','/the/i','/the/d','/the/s','/the/c','/the/y', -r '/^(the)/p' 
 `'//!'表示除了匹配内容//以外的行,'1!d'：除了第一行，其它行都删掉`
	'1,2!a','1!i','1!d','1!s','1!c','1!y','1!p' 
 `'//,+n' 表示匹配行及其下n行`
	'/the/,+1a','/the/,+2i','/the/,+2d','/the/,+2s','/the/,+2c','/the/,+2y','/the/,+2p' 
 `'1,5{<!-- -->/hello/命令1;//命令2;..}' 一对多匹配，表示先匹配1-5行，然后分别执行不同的匹配和命令`


` 选项操作`
` -e  ：执行多个命令，以 ; 分隔`
sed -e '2ahello world;s/hello/Hello/' datafile
` -f  ：从文件读取命令，预先将sed的命令部分保存在文件中，一行操作一次`
file1：
s/hello/Hello
3aHello World
4d
` -f 操作：`
sed -f file1 datafile
` -n  ：不输出内存缓存的内容，默认会输出文件和内存中的内容，内存中保存到是匹配行操作后的内容`
sed -n '2,$p' datafile        如果内容-n，则会出现重复的2到最后一行
` -r  ：使用正则表达式，用于使用正则表达式匹配行时`
sed -n  -r '/^(3 the)/p' datafile
` -i 或 -i.bak ：以上所有操作都只是在缓存中完成，并不会修改原文件的内容，-i.bak可对原文件备份`
sed -i 's/hello/Hello/' datafile          在原文件上直接修改datafile
sed -i.bak 's/hello/Hello/' datafile      会得到修改后文件datafile和原备份文件datafile.bak

` 标志`
sed 's/hello/Hello/2' datafile               替换一行中的第二处hello为Hello
sed 's/hello/Hello/g' datafile               将datafile文件中的所有hello替换为Hello
sed  '3s/hello/Hello/p' datafile             打印文本内容，类似于-p命令选项
sed  '3s/hello/Hello/w filename' datafile    将修改的内容存入新filename文件中
sed  's/hello/Hello/gpw filename' datafile   可多个标志

```

### 十二、Shell数据筛选与处理-awk

参考的内容。
